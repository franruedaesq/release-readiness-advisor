name: Deploy Release Advisor

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  ECR_REPOSITORY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/release-readiness-advisor/backend

jobs:
  build-and-push-image:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & push image
        run: |
          set -euo pipefail
          docker build -t "$ECR_REPOSITORY:latest" -t "$ECR_REPOSITORY:${{ github.sha }}" -f ./apps/backend/Dockerfile .
          docker push "$ECR_REPOSITORY" --all-tags

  deploy-to-ec2:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: build-and-push-image
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform (disable wrapper)
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6
          terraform_wrapper: false

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init -no-color

      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -auto-approve -no-color

      - name: Read Terraform outputs (robust & sanitized)
        id: tf
        shell: bash
        working-directory: ./terraform
        run: |
          set -euo pipefail

          # 1) Correct flag ordering and capture; sanitize to only an IPv4
          raw="$(terraform output -no-color -raw ec2_public_ip 2>/dev/null || true || printf '')"
          ip="$(printf '%s\n' "$raw" | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n1 || true)"

          # 2) Fallback: JSON output + jq (sanitize again)
          if [[ -z "${ip}" ]]; then
            if ! command -v jq >/dev/null 2>&1; then
              sudo apt-get update -y && sudo apt-get install -y jq
            fi
            json="$(terraform output -no-color -json 2>/dev/null || true || printf '{}')"
            ip="$(printf '%s' "$json" | jq -r '.ec2_public_ip.value // empty' | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n1 || true)"
          fi

          # 3) Fallback: query AWS by tag (sanitize again)
          if [[ -z "${ip}" ]]; then
            region="${{ secrets.AWS_REGION }}"
            ip="$(aws ec2 describe-instances \
                  --region "$region" \
                  --filters 'Name=tag:Name,Values=Release-Advisor-Server' 'Name=instance-state-name,Values=running' \
                  --query 'Reservations[].Instances[].PublicIpAddress' \
                  --output text 2>/dev/null | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n1 || true)"
          fi

          if [[ -z "${ip}" ]]; then
            echo "Could not determine EC2 public IP via Terraform or AWS CLI" >&2
            exit 1
          fi

          # Write exactly one KEY=VALUE line
          echo "ip=$ip" >> "$GITHUB_OUTPUT"

      # Copy docker-compose file to the instance
      - name: Copy docker-compose to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ steps.tf.outputs.ip }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          source: "docker-compose.prod.yml"
          target: "/home/ubuntu/"
          overwrite: true

      # Run remote commands on the instance

      - name: Deploy on EC2 via SSH
        uses: appleboy/ssh-action@v1.0.3
        env: # make these available on the runner
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }} # optional, if your compose uses it
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        with:
          host: ${{ steps.tf.outputs.ip }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          script_stop: true
          # forward the runner envs above into the remote shell
          envs: AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,AWS_SESSION_TOKEN,AWS_REGION,AWS_DEFAULT_REGION,AWS_ACCOUNT_ID,OPENAI_API_KEY
          script: |
            set -euo pipefail

            # ---------- Normalize region & account ----------
            export AWS_REGION="${AWS_REGION:-${AWS_DEFAULT_REGION:-${{ secrets.AWS_REGION }}}}"
            export AWS_DEFAULT_REGION="$AWS_REGION"
            export AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID:-${{ secrets.AWS_ACCOUNT_ID }}}"

            # ---------- AWS CLI v2 (Ubuntu 24.04) ----------
            if ! command -v aws >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y curl unzip
              ARCH="$(uname -m)"
              if [ "$ARCH" = "x86_64" ]; then
                URL="https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"
              elif [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
                URL="https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip"
              else
                echo "Unsupported arch: $ARCH" >&2
                exit 1
              fi
              TMP="$(mktemp -d)"
              curl -fsSL "$URL" -o "$TMP/awscliv2.zip"
              unzip -q "$TMP/awscliv2.zip" -d "$TMP"
              sudo "$TMP/aws/install" --update
              rm -rf "$TMP"
            fi

            # ---------- Ensure Docker Compose plugin ----------
            if ! docker compose version >/dev/null 2>&1; then
              sudo apt-get update -y
              sudo apt-get install -y docker-compose-plugin
            fi

            # ---------- ECR login ----------
            aws ecr get-login-password --region "$AWS_REGION" \
              | docker login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

            cd /home/ubuntu

            # Clean up bad directory from earlier runs
            if [ -d /home/ubuntu/docker-compose.yml ]; then
              sudo rm -rf /home/ubuntu/docker-compose.yml
            fi

            # Put compose file in place
            if [ -f /home/ubuntu/docker-compose.prod.yml ]; then
              mv -f /home/ubuntu/docker-compose.prod.yml /home/ubuntu/docker-compose.yml
            fi
            sudo chown ubuntu:ubuntu /home/ubuntu/docker-compose.yml || true

            # ---------- Provide .env for compose variable expansion ----------
            cat >/home/ubuntu/.env <<EOF
            AWS_ACCOUNT_ID=${AWS_ACCOUNT_ID}
            AWS_REGION=${AWS_REGION}
            OPENAI_API_KEY=${OPENAI_API_KEY:-}
            EOF

            echo "Using image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/release-readiness-advisor/backend:latest"

            # ---------- Deploy ----------
            docker compose pull
            docker compose up -d --force-recreate --remove-orphans
